
# RDB vs GraphDB (MySQL vs Neo4j) 성능 비교

버전 트리(계층/그래프 구조)를 **MySQL**과 **Neo4j**에 동일하게 저장하고,  
조상/자손/LCA 등의 쿼리를 실행하여 성능을 테스트한 실험 예제입니다.

## 1. 실험 데이터 및 시나리오

- **데이터 구조**
  - **체인(단순 일자형)** / **이진 트리** / **복합 트리** / **다중 부모(DAG)**
  - 노드 속성: `title, content, author, createdTime`
- **쿼리 시나리오**
  1. 특정 노드의 **조상(ancestor)** 조회  
  2. 특정 노드의 **자손(descendant)** 조회  
  3. 두 노드의 **공통 조상(LCA)**  
  4. (조건부) `author`, `title`, `createdTime` 필터 적용

## 2. 환경 및 실행 방법

1. **Docker 환경 준비**

   ```bash
   # (현재 디렉터리에 docker-compose.yml이 있다고 가정)
   docker-compose up --build
   ```

   - MySQL, Neo4j 컨테이너가 올라옵니다.

2. **Spring Boot 실행**

   - 서버가 8080 포트에서 구동됩니다.

3. **테스트 실행**

   - MySQL, Neo4j 각각에 동일한 데이터 구조를 삽입 후,
     조상/자손/LCA 쿼리를 수행하며 시간 측정 로그를 출력합니다.

## 3. 주요 결과

### (A) 체인/이진/복합 트리 - 평균 응답 시간

| 항목                      | 체인 - MySQL | 체인 - Neo4j | 이진 트리 - MySQL | 이진 트리 - Neo4j | 복합 트리 - MySQL | 복합 트리 - Neo4j |
|---------------------------|-------------:|-------------:|------------------:|------------------:|------------------:|------------------:|
| **전체 조상**            |      168 ms  |      383 ms  |            2 ms   |            9 ms   |           2 ms    |           5 ms    |
| **전체 후손**            |       67 ms  |      225 ms  |           38 ms   |          107 ms   |          40 ms    |         104 ms    |
| **랜덤 노드 조상(10회)** |       30 ms  |       93 ms  |            1 ms   |            4 ms   |           1 ms    |           3 ms    |
| **LCA**                  |      132 ms  |      320 ms  |           10 ms   |           10 ms   |          12 ms    |          11 ms    |

#### 배율(Neo4j / MySQL)

| 항목                   | 체인  | 이진 트리 | 복합 트리 |
|------------------------|:-----:|:--------:|:--------:|
| **전체 조상**          | 2.2x  | 4.5x     | 2.5x     |
| **전체 후손**          | 3.3x  | 2.8x     | 2.6x     |
| **랜덤 노드 조상**     | 3.1x  | 4.0x     | 3.0x     |
| **LCA**                | 2.4x  | 1.0x     | 0.9x     |

### (B) 다중 부모(DAG) 시나리오 - 간단 요약

예: `author='kanguk' AND title LIKE '%pdf%'` 조상 조회, 자손 중 `createdTime>=2025-03` 등등
- 대다수 쿼리에서 **MySQL**이 Neo4j 대비 빠른 편이었으며,
- **DAG** 구조여도 재귀 CTE로 충분히 커버 가능하다는 결과.

## 4. 결론

- **단순 계층 구조**(체인/트리/DAG)에서는 MySQL 재귀 CTE로도 충분히 빠른 쿼리가 가능.
- **Neo4j**는 **복잡한 그래프**(SNS 관계, 다중 경로 탐색 등)에서 이점이 크지만, 이번 시나리오에서는 큰 우위 없음.
- 본 프로젝트에서는 **MySQL**을 사용하는 것이 더 타당하다는 결론에 도달.

---

> **추가 참고**  
> - [코드](./src/...) 에서 `DagVersionService`, `DagScenarioTest`를 보면  
>   다중 부모 DAG 데이터(1만 개) 생성 및 시나리오 쿼리를 확인할 수 있습니다.
> - 이후 관계가 훨씬 복잡해지면 Neo4j 재검토 가능
```
